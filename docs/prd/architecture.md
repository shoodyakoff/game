# Архитектура проекта PM-Game

## Общая структура
Проект PM-Game представляет собой веб-приложение полного цикла, состоящее из клиентской и серверной частей с централизованным хранилищем данных и системой аутентификации.

## Технологический стек

### Фронтенд
- **Основной фреймворк**: Next.js (на базе React)
- **Язык программирования**: TypeScript
- **Управление состоянием**: Redux Toolkit
- **Стилизация**: Tailwind CSS + CSS Modules
- **UI компоненты**: Собственная библиотека компонентов
- **Сетевые запросы**: Axios с интерцепторами для обработки токенов
- **Анимации**: Framer Motion
- **Локальное хранилище**: IndexedDB для кэширования и оффлайн-режима
- **Тестирование**: Jest + React Testing Library
- **Валидация форм**: Formik + Yup

### Бэкенд
- **Платформа**: Node.js
- **Фреймворк**: Express
- **Язык программирования**: TypeScript
- **API-документация**: Swagger/OpenAPI
- **Аутентификация**: JWT (jsonwebtoken) с refresh токенами
- **Валидация**: Joi/Yup
- **Безопасность**: Helmet, CORS, Rate Limiting, sanitize-html
- **Логирование**: Winston + MongoDB для хранения логов
- **Кэширование**: Redis

### База данных
- **Основная БД**: MongoDB
- **ODM**: Mongoose
- **Индексация**: Для оптимизации запросов по часто используемым полям
- **Резервное копирование**: Автоматические бэкапы с заданной периодичностью
- **Шардинг**: Подготовка для горизонтального масштабирования

### Инфраструктура
- **Хостинг фронтенда**: Vercel/Netlify с CDN
- **Хостинг бэкенда**: AWS EC2/Digital Ocean с балансировкой нагрузки
- **База данных**: MongoDB Atlas с геораспределением
- **Кэширование**: Redis Cloud
- **CI/CD**: GitHub Actions с автоматическим деплоем
- **Мониторинг**: Sentry для отслеживания ошибок, Datadog для метрик
- **Контейнеризация**: Docker + Docker Compose
- **Оркестрация**: Kubernetes для продакшн среды

## Архитектура приложения

### Фронтенд

#### Слои приложения
1. **Слой представления (UI)**
   - Компоненты пользовательского интерфейса
   - Страницы приложения
   - Маршрутизация
   - Обработка ошибок и состояний загрузки

2. **Слой управления состоянием**
   - Redux store
   - Reducers и actions
   - Селекторы
   - Middleware для асинхронных операций (Redux Thunk)

3. **Слой бизнес-логики**
   - Сервисы для работы с данными
   - Утилиты и хелперы
   - Бизнес-правила
   - Валидация

4. **Слой доступа к данным**
   - API-клиенты
   - Адаптеры данных
   - Кэширование
   - Стратегии оффлайн-режима

#### Структура директорий
```
frontend/
  ├── public/                # Статические файлы
  ├── src/
  │   ├── assets/            # Изображения, звуки, шрифты
  │   ├── components/        # Компоненты
  │   │   ├── auth/          # Компоненты авторизации
  │   │   ├── character/     # Компоненты персонажа
  │   │   ├── game/          # Игровые компоненты
  │   │   ├── map/           # Компоненты карты
  │   │   ├── ui/            # UI-компоненты
  │   │   └── layout/        # Компоненты макета
  │   ├── pages/             # Страницы приложения
  │   │   ├── api/           # API-роуты Next.js
  │   │   ├── auth/          # Страницы авторизации
  │   │   ├── character/     # Страницы персонажа
  │   │   ├── map/           # Страница карты
  │   │   ├── level/         # Страницы уровней
  │   │   └── profile/       # Страницы профиля
  │   ├── store/             # Redux store
  │   │   ├── slices/        # Redux slices
  │   │   ├── actions/       # Redux actions
  │   │   ├── selectors/     # Redux selectors
  │   │   └── middleware/    # Middleware для Redux
  │   ├── services/          # Сервисы для работы с API
  │   │   ├── api/           # API-клиенты
  │   │   ├── auth/          # Сервисы авторизации
  │   │   ├── sync/          # Сервисы синхронизации
  │   │   ├── storage/       # Сервисы локального хранения
  │   │   └── game/          # Игровые сервисы
  │   ├── utils/             # Утилиты и хелперы
  │   ├── hooks/             # Кастомные React-хуки
  │   ├── types/             # TypeScript типы и интерфейсы
  │   ├── constants/         # Константы приложения
  │   └── styles/            # Глобальные стили
  ├── .eslintrc.js           # Конфигурация ESLint
  ├── .prettierrc            # Конфигурация Prettier
  ├── tsconfig.json          # Конфигурация TypeScript
  ├── next.config.js         # Конфигурация Next.js
  ├── tailwind.config.js     # Конфигурация Tailwind CSS
  ├── jest.config.js         # Конфигурация Jest
  └── package.json           # Зависимости и скрипты
```

### Бэкенд

#### Слои приложения
1. **API-слой**
   - Контроллеры
   - Маршруты
   - Middleware
   - Валидация входных данных

2. **Слой бизнес-логики**
   - Сервисы
   - Менеджеры
   - Валидаторы
   - Механизмы авторизации

3. **Слой доступа к данным**
   - Модели
   - Репозитории
   - DTO (Data Transfer Objects)
   - Кэширование

4. **Инфраструктурный слой**
   - Логирование
   - Обработка ошибок
   - Мониторинг и метрики
   - Конфигурация

#### Структура директорий
```
backend/
  ├── src/
  │   ├── api/               # API-слой
  │   │   ├── controllers/   # Контроллеры
  │   │   ├── middlewares/   # Middleware
  │   │   ├── routes/        # Маршруты
  │   │   └── validators/    # Валидаторы запросов
  │   ├── config/            # Конфигурации
  │   │   ├── database.js    # Конфигурация БД
  │   │   ├── server.js      # Конфигурация сервера
  │   │   ├── cache.js       # Конфигурация кэширования
  │   │   └── auth.js        # Конфигурация авторизации
  │   ├── services/          # Бизнес-логика
  │   │   ├── auth/          # Сервисы авторизации
  │   │   ├── character/     # Сервисы персонажей
  │   │   ├── level/         # Сервисы уровней
  │   │   ├── sync/          # Сервисы синхронизации
  │   │   └── user/          # Сервисы пользователей
  │   ├── models/            # Модели данных
  │   │   ├── user.js        # Модель пользователя
  │   │   ├── character.js   # Модель персонажа
  │   │   ├── level.js       # Модель уровня
  │   │   ├── progress.js    # Модель прогресса
  │   │   ├── sync.js        # Модель синхронизации
  │   │   └── item.js        # Модель предмета
  │   ├── utils/             # Утилиты и хелперы
  │   │   ├── logger.js      # Логирование
  │   │   ├── error.js       # Обработка ошибок
  │   │   ├── metrics.js     # Сбор метрик
  │   │   └── security.js    # Безопасность
  │   ├── database/          # Код для работы с БД
  │   │   ├── connection.js  # Подключение к БД
  │   │   ├── repositories/  # Репозитории для работы с данными
  │   │   └── seeds/         # Сиды для начальных данных
  │   ├── cache/             # Работа с кэшем
  │   │   ├── redis.js       # Подключение к Redis
  │   │   └── strategies.js  # Стратегии кэширования
  │   └── app.js             # Входная точка приложения
  ├── tests/                 # Тесты
  │   ├── unit/              # Модульные тесты
  │   ├── integration/       # Интеграционные тесты
  │   └── e2e/               # E2E тесты
  ├── .eslintrc.js           # Конфигурация ESLint
  ├── .prettierrc            # Конфигурация Prettier
  ├── .env.example           # Пример .env файла
  ├── jest.config.js         # Конфигурация Jest
  ├── tsconfig.json          # Конфигурация TypeScript
  ├── Dockerfile             # Конфигурация Docker
  ├── docker-compose.yml     # Конфигурация Docker Compose
  └── package.json           # Зависимости и скрипты
```

### Модель данных

#### Основные сущности
1. **User (Пользователь)**
   - Данные аутентификации (email, хешированный пароль)
   - Базовая информация профиля (имя, дата регистрации)
   - Настройки и предпочтения
   - Роли и разрешения
   - Информация о сессиях
   - Связь с персонажем

2. **Character (Персонаж)**
   - Имя и тип
   - Характеристики
   - Инвентарь
   - Прогресс
   - История действий
   - Специальные способности

3. **Level (Уровень)**
   - Информация об уровне (название, описание, тип)
   - Содержимое уровня (диалоги, задания)
   - Варианты прохождения
   - Оптимальные решения
   - Зависимости и требования
   - Награды

4. **Item (Предмет)**
   - Название и описание
   - Тип и эффекты
   - Принадлежность персонажу
   - Редкость и ценность
   - Условия получения и использования

5. **Progress (Прогресс)**
   - Статус прохождения уровней
   - История действий
   - Принятые решения
   - Достижения
   - Статистика
   - Версионность

6. **Sync (Синхронизация)**
   - История синхронизаций
   - Разрешение конфликтов
   - Временные метки
   - Информация об устройствах
   - Версионность данных

#### Связи между сущностями
- User -> Character (One-to-One)
- Character -> Items (One-to-Many)
- User -> Progress (One-to-One)
- Progress -> Levels (Many-to-Many)
- User -> Sync (One-to-Many)
- Level -> Level (Many-to-Many, для зависимостей)

## Потоки данных

### Аутентификация
1. Пользователь вводит учетные данные (email, пароль)
2. Фронтенд отправляет запрос на бэкенд (POST `/api/auth/login`)
3. Бэкенд валидирует данные, проверяет учетные данные
4. Бэкенд создает JWT токен и refresh токен
5. Фронтенд сохраняет токены (JWT в памяти, refresh в httpOnly cookie)
6. Фронтенд использует JWT для авторизации последующих запросов
7. При истечении JWT, автоматически используется refresh токен для обновления
8. При выходе из системы удаляются все токены

### Создание персонажа
1. Пользователь после авторизации попадает на страницу создания персонажа
2. Пользователь выбирает тип персонажа и задает имя
3. Данные отправляются на сервер (POST `/api/characters/create`)
4. Сервер валидирует данные, создает персонажа в базе
5. Сервер создает начальные характеристики и добавляет стартовые предметы
6. Информация о персонаже возвращается клиенту
7. Пользователь перенаправляется на карту уровней

### Игровой процесс
1. Пользователь выбирает уровень на карте
2. Фронтенд запрашивает данные уровня с бэкенда (GET `/api/levels/:id/content`)
3. Пользователь взаимодействует с уровнем, принимает решения
4. Фронтенд периодически сохраняет прогресс на бэкенд (POST `/api/levels/:id/progress`)
5. По завершении уровня результаты отправляются на бэкенд (POST `/api/levels/:id/complete`)
6. Бэкенд обрабатывает результаты, обновляет прогресс, рассчитывает награды
7. Бэкенд возвращает саммари и обновляет статус уровней
8. Фронтенд отображает результаты и обновляет карту уровней

### Синхронизация данных
1. Пользователь входит в систему на новом устройстве
2. Клиент запрашивает текущее состояние с сервера (GET `/api/users/:id/state`)
3. Клиент сравнивает локальные данные с серверными (если есть)
4. При обнаружении конфликта инициируется процесс синхронизации (POST `/api/users/:id/sync`)
5. Сервер разрешает конфликты по заданной стратегии
6. Синхронизированные данные возвращаются клиенту
7. Клиент обновляет локальное состояние

## Масштабирование и производительность

### Стратегии масштабирования
1. **Горизонтальное масштабирование**
   - Несколько инстансов бэкенда за балансировщиком нагрузки
   - Шардирование MongoDB для распределения нагрузки
   - Репликация базы данных для отказоустойчивости
   - Статический контент в CDN

2. **Оптимизация базы данных**
   - Индексация полей для частых запросов
   - Денормализация данных для ускорения чтения
   - Кэширование запросов в Redis
   - Партиционирование по времени для исторических данных

3. **Кэширование**
   - Многоуровневое кэширование (клиент, CDN, сервер, база данных)
   - Сегментация кэша по типам данных
   - Политики инвалидации кэша
   - Предварительная загрузка часто используемых данных

4. **Асинхронная обработка**
   - Очереди сообщений для асинхронных операций
   - Фоновые задачи для тяжелых вычислений
   - Периодические задачи для агрегации данных
   - Системы нотификаций для реал-тайм обновлений

### Стратегии оптимизации производительности
1. **Фронтенд**
   - Ленивая загрузка компонентов и маршрутов
   - Оптимизация бандлов (разделение кода, tree-shaking)
   - Предзагрузка критичных ресурсов
   - Прогрессивная загрузка изображений
   - Оптимизация рендеринга (мемоизация, виртуализация)
   - Service Workers для кэширования и оффлайн-режима

2. **Бэкенд**
   - Оптимизация запросов к базе данных
   - Пагинация и ограничение размера ответов
   - Компрессия данных (gzip, brotli)
   - Балансировка нагрузки между инстансами
   - Асинхронная обработка тяжелых операций

3. **Сеть**
   - Использование HTTP/2 или HTTP/3
   - Географическое распределение через CDN
   - Оптимизация размера данных (JSON-минификация)
   - Инкрементальные обновления вместо передачи полных данных

4. **Мониторинг и оптимизация**
   - Сбор метрик производительности
   - Профилирование узких мест
   - Автоматические тесты производительности
   - Оповещения о деградации производительности

## Безопасность

### Защита данных пользователей
1. **Аутентификация и авторизация**
   - JWT с коротким сроком жизни + secure refresh tokens
   - Многофакторная аутентификация для чувствительных операций
   - Ролевой доступ (RBAC)
   - Сессии с возможностью отзыва
   - Проверки на все API-эндпоинты

2. **Хранение данных**
   - Хеширование паролей (bcrypt с солью)
   - Шифрование чувствительных данных
   - Анонимизация данных для аналитики
   - Изоляция данных различных пользователей
   - Минимизация хранимых PII (Personally Identifiable Information)

3. **Передача данных**
   - HTTPS для всех соединений
   - HSTS для предотвращения downgrade-атак
   - Шифрование в транзите
   - Подписывание важных запросов

### Защита от атак
1. **Защита от веб-уязвимостей**
   - Защита от XSS (строгий Content-Security-Policy)
   - Защита от CSRF (anti-CSRF токены)
   - Защита от инъекций (параметризованные запросы, валидация)
   - Защита от атак перебором (rate limiting, блокировка IP)
   - Безопасные заголовки HTTP (X-Content-Type-Options, X-Frame-Options)

2. **Сетевая безопасность**
   - Брандмауэр на уровне сети
   - Брандмауэр веб-приложений (WAF)
   - Ограничение доступа к API по IP (для администрирования)
   - VPN для доступа к критическим компонентам
   - Мониторинг подозрительной активности

3. **Безопасность инфраструктуры**
   - Регулярное обновление зависимостей
   - Сканирование уязвимостей
   - Принцип наименьших привилегий
   - Изоляция компонентов (контейнеры, микросервисы)
   - Резервное копирование и планы восстановления

### Аудит и мониторинг
1. **Логирование**
   - Централизованное логирование всех действий
   - Надежное хранение логов (защита от удаления)
   - Структурированные логи для анализа
   - Журналирование действий администраторов
   - Логирование изменений в базе данных

2. **Мониторинг безопасности**
   - Мониторинг подозрительной активности
   - Оповещения о необычном поведении
   - Мониторинг попыток несанкционированного доступа
   - Анализ трендов и шаблонов для предотвращения атак
   - Интеграция с системами обнаружения вторжений

3. **Обработка инцидентов**
   - План реагирования на инциденты
   - Процедуры отчетности и коммуникации
   - Автоматизированные реакции на атаки
   - Анализ инцидентов и извлечение уроков
   - Периодические тренировки по реагированию

## Отказоустойчивость и восстановление

### Стратегии отказоустойчивости
1. **Избыточность**
   - Несколько инстансов приложения
   - Репликация базы данных
   - Географическое распределение
   - Резервные каналы связи

2. **Изоляция отказов**
   - Микросервисная архитектура
   - Circuit breakers для предотвращения каскадных отказов
   - Таймауты и повторные попытки
   - Деградация функциональности при частичных отказах

3. **Автоматическое восстановление**
   - Автоматический перезапуск упавших сервисов
   - Health checks и самовосстановление
   - Автоматическое масштабирование при нагрузке
   - Перенаправление трафика от неисправных компонентов

### Резервное копирование и восстановление
1. **Стратегия резервного копирования**
   - Ежедневные полные резервные копии
   - Инкрементальные копии каждый час
   - Снапшоты базы данных перед критическими операциями
   - Географически распределенное хранение копий

2. **Проверка и восстановление**
   - Регулярные тесты восстановления
   - Автоматизированная проверка целостности резервных копий
   - Документированные процедуры восстановления
   - Минимизация времени восстановления (RTO)
   - Минимизация потери данных (RPO)

## Развитие и расширение проекта

### Стратегия развития
1. **Модульная архитектура**
   - Независимые модули с четкими интерфейсами
   - Возможность замены компонентов
   - API-первый подход для всех функций
   - Контрактное тестирование между компонентами

2. **Версионирование**
   - Семантическое версионирование API
   - Обратная совместимость между версиями
   - Стратегия миграции данных
   - Параллельное поддержание нескольких версий

3. **Тестирование и качество**
   - Непрерывная интеграция (CI)
   - Автоматические тесты (юнит, интеграционные, e2e)
   - Анализ качества кода
   - Мониторинг производительности
   - A/B тестирование новых функций

### Планы будущего развития
1. **Расширение игрового контента**
   - Редактор уровней для администраторов
   - Система создания пользовательского контента
   - Интеграция с AI для генерации персонализированного контента
   - Расширенные аналитические инструменты для обучения

2. **Социальные функции**
   - Многопользовательские сценарии
   - Совместное прохождение уровней
   - Соревновательные элементы и рейтинги
   - Системы достижений и признания

3. **Интеграции**
   - API для образовательных платформ
   - Интеграция с системами управления обучением (LMS)
   - Экспорт и импорт данных
   - Мобильные приложения 