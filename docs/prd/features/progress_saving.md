# Сохранение прогресса

## Описание
Механизм сохранения и синхронизации прогресса пользователя, обеспечивающий сохранение всех достижений, решений и состояния игры между сессиями и устройствами, с полной интеграцией с базой данных и системой аутентификации.

## Пользовательский сценарий
1. Пользователь авторизуется в системе
2. Система обращается к API для получения последнего сохраненного состояния
3. Система автоматически загружает последнее сохраненное состояние:
   - Текущий персонаж
   - Доступные и пройденные уровни
   - Полученные предметы и награды
   - Статистика и достижения
4. В процессе игры система автоматически сохраняет прогресс через API при определенных событиях:
   - Завершение уровня
   - Получение награды
   - Изменение статуса персонажа
   - Периодические автосохранения
5. При выходе из игры все изменения сохраняются в базе данных
6. При повторном входе пользователь продолжает с последнего сохраненного состояния, синхронизируя данные между клиентом и сервером

## Типы сохраняемых данных

### 1. Данные профиля пользователя
- Базовая информация аккаунта
- Настройки пользователя
- История входов

### 2. Данные персонажа
- Имя и тип персонажа
- Характеристики и уровень
- Предметы и экипировка
- Навыки и способности

### 3. Данные прогресса по уровням
- Статус прохождения каждого уровня
- История принятых решений
- Полученные результаты и оценки
- Количество попыток и время прохождения

### 4. Данные наград и достижений
- Полученные предметы
- Разблокированные достижения
- Опыт и другие показатели прогресса
- Бонусы и модификаторы

## Технические требования

### Фронтенд
1. Механизм кэширования данных на клиенте
   - Локальное сохранение текущего состояния (IndexedDB или localStorage)
   - Отображение индикаторов сохранения
   - Обработка конфликтов между локальным и серверным сохранением
   - Стратегия оффлайн-работы с последующей синхронизацией

2. Компоненты:
   - Индикатор статуса синхронизации
   - Система уведомлений о сохранении/загрузке
   - Интерфейс управления сохранениями (если применимо)
   - Компонент для разрешения конфликтов синхронизации
   - Обработка и отображение ошибок синхронизации

### Бэкенд
1. API для получения текущего состояния
   - Метод: GET
   - Endpoint: `/api/users/:id/state`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Возвращает полную информацию о текущем состоянии пользователя
   - Поддержка частичного получения данных через параметры запроса

2. API для сохранения текущего состояния
   - Метод: PUT
   - Endpoint: `/api/users/:id/state`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Входные данные:
     - user_id (из токена авторизации)
     - state_data (новое состояние)
     - timestamp (время сохранения)
   - Валидация входных данных
   - Атомарное обновление состояния

3. API для синхронизации между устройствами
   - Метод: POST
   - Endpoint: `/api/users/:id/sync`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Входные данные:
     - user_id (из токена авторизации)
     - device_id (идентификатор устройства)
     - local_state (локальное состояние)
     - last_sync (время последней синхронизации)
   - Распознавание и разрешение конфликтов
   - Журналирование синхронизаций для аудита

4. API для резервного копирования состояния
   - Метод: POST
   - Endpoint: `/api/users/:id/backup`
   - Требует авторизации (JWT токен)
   - Создает резервную копию текущего состояния
   - Возвращает идентификатор резервной копии

### База данных
1. Коллекция `user_state`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `character_state`: Object (состояние персонажа)
   - `level_progress`: Object (прогресс по уровням)
   - `inventory`: Array (инвентарь персонажа)
   - `achievements`: Array (достижения)
   - `settings`: Object (настройки пользователя)
   - `last_updated`: Date (время последнего обновления)
   - `version`: Number (версия состояния)
   - `is_deleted`: Boolean (флаг удаления)

2. Коллекция `sync_history`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `device_id`: String (идентификатор устройства)
   - `sync_timestamp`: Date (время синхронизации)
   - `sync_data`: Object (данные синхронизации)
   - `status`: String (статус синхронизации)
   - `conflict_resolution`: String (способ разрешения конфликта, если был)
   - `ip_address`: String (IP-адрес для аудита)

3. Коллекция `backups`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `created_at`: Date (время создания копии)
   - `state_data`: Object (полная копия состояния)
   - `reason`: String (причина создания резервной копии)
   - `created_by`: String (кто создал: система или пользователь)

### Индексы базы данных
1. `user_state`:
   - `user_id`: 1 (для быстрого поиска)
   - `last_updated`: -1 (для сортировки по времени)

2. `sync_history`:
   - `user_id`: 1, `device_id`: 1 (для фильтрации по пользователю и устройству)
   - `sync_timestamp`: -1 (для сортировки по времени)

## Механизм синхронизации
1. Последовательность событий при входе пользователя:
   - Пользователь авторизуется через JWT
   - Клиент проверяет наличие локальных данных
   - Клиент запрашивает последнее состояние с сервера с временной меткой последней синхронизации
   - Проводится сравнение локальных и серверных данных на основе временных меток и версионирования
   - При конфликте: применяется стратегия разрешения конфликтов
   - Синхронизированные данные загружаются на клиент
   - Обновляется временная метка последней синхронизации

2. Периодическая синхронизация:
   - Автоматическое сохранение при достижении контрольных точек с отправкой на сервер
   - Фоновая синхронизация с заданным интервалом (каждые 5 минут)
   - Принудительное сохранение при выходе из приложения
   - Дифференциальные обновления для уменьшения объема передаваемых данных

3. Обработка конфликтов:
   - Стратегия разрешения конфликтов на основе временных меток и версионирования
   - Приоритет серверных данных при невозможности определить новизну
   - Логирование конфликтов для анализа и поддержки
   - Механизм ручного разрешения конфликтов для критических данных

### Обеспечение целостности данных
1. Транзакционные обновления состояния
2. Версионирование данных
3. Автоматические резервные копии перед значительными изменениями
4. Механизм восстановления из резервных копий
5. Валидация структуры данных на клиенте и сервере

## Безопасность
1. Аутентификация через JWT для всех API-запросов
2. Проверка прав доступа на сервере
3. Шифрование чувствительных данных
4. Ограничение частоты запросов (rate limiting)
5. Журналирование операций для аудита
6. Защита от CSRF и инъекций

## Интеграционные требования
1. Сохранение должно происходить без прерывания игрового процесса
2. Система должна корректно обрабатывать сценарии с отсутствием сетевого соединения
3. Необходима защита от потери данных при сбоях
4. Интеграция с системой аутентификации для обеспечения безопасности данных пользователя
5. Минимизация объема передаваемых данных для экономии трафика
6. Поддержка разных версий клиента через совместимость форматов данных

## Критерии готовности
1. Прогресс пользователя корректно сохраняется при всех ключевых игровых событиях
2. Данные успешно синхронизируются между разными устройствами при входе пользователя
3. Система корректно обрабатывает конфликты при синхронизации
4. Производительность сохранения не влияет на игровой процесс
5. Система обеспечивает безопасность данных пользователя
6. Пользователь может видеть индикацию статуса сохранения/загрузки
7. Система корректно работает при временном отсутствии соединения
8. Механизм резервного копирования и восстановления работает корректно
9. Данные сохраняются атомарно, без частичных обновлений
10. Система способна обрабатывать большое количество одновременных запросов 