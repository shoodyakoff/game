# Сохранение прогресса

## Общее описание
Система сохранения прогресса позволяет игрокам сохранять свой прогресс в игре, включая выбранного персонажа, пройденные уровни, полученные достижения и предметы. Текущая реализация использует localStorage браузера, с планами по миграции на MongoDB для обеспечения синхронизации между устройствами.

## Текущая реализация

### Хранение данных
- **Выбранный персонаж**: сохраняется в Redux store и дублируется в localStorage
- **Прогресс по уровням**: сохраняется в localStorage в ключах вида `level1_progress`, `level2_progress`
- **Завершенные уровни**: сохраняются в localStorage в ключе `completedLevels`
- **Достижения и награды**: временно сохраняются в компонентах и отображаются на экране завершения уровня

### Механизм сохранения
- **Автоматическое сохранение**: при изменении состояния в Redux
- **Периодическое сохранение**: при прохождении этапов уровня
- **Сохранение при выходе**: при завершении уровня или выходе из игры

### Восстановление данных
- При запуске приложения данные загружаются из localStorage в Redux store
- При переходе на страницу уровня проверяется наличие сохраненного прогресса
- При наличии сохраненного прогресса предлагается продолжить с последнего этапа

## Планируемая реализация (MongoDB)

### Структура базы данных
- **Коллекция Users**: основная информация о пользователе
- **Коллекция Characters**: информация о персонажах пользователя
- **Коллекция Progress**: прогресс по уровням и этапам
- **Коллекция Achievements**: полученные достижения
- **Коллекция Rewards**: полученные предметы и награды

### API Endpoints

#### GET /api/progress
- Получение текущего прогресса пользователя
- Требует JWT-аутентификацию
- Возвращает данные о прогрессе, достижениях и наградах

#### POST /api/progress/save
- Сохранение текущего прогресса
- Требует JWT-аутентификацию
- Принимает обновленные данные о прогрессе
- Возвращает подтверждение сохранения и актуальные данные

#### GET /api/progress/level/:levelId
- Получение прогресса по конкретному уровню
- Требует JWT-аутентификацию
- Возвращает данные о прогрессе по указанному уровню

#### POST /api/progress/level/:levelId/complete
- Отметка уровня как завершенного
- Требует JWT-аутентификацию
- Принимает данные о результатах прохождения
- Возвращает обновленный список завершенных уровней

### Синхронизация между устройствами
- Проверка актуальности данных при запуске приложения
- Сравнение временных меток для определения более актуальной версии
- Разрешение конфликтов при синхронизации (приоритет серверных данных)
- Периодическая синхронизация во время игровой сессии

## План миграции

### Этап 1: Подготовка
- Создание необходимых коллекций в MongoDB
- Разработка API для работы с прогрессом
- Тестирование API с моковыми данными

### Этап 2: Реализация сохранения
- Добавление кода для отправки данных на сервер
- Интеграция с существующей логикой сохранения в localStorage
- Двойное сохранение (в localStorage и MongoDB) для надежности

### Этап 3: Реализация восстановления
- Загрузка данных с сервера при запуске приложения
- Сравнение с локальными данными и выбор наиболее актуальных
- Восстановление состояния приложения из серверных данных

### Этап 4: Полная миграция
- Переход на полное использование MongoDB
- Сохранение в localStorage только для оффлайн-режима
- Синхронизация при восстановлении соединения

## Технические детали текущей реализации

### Redux Store (характеристики персонажа)
```typescript
// characterSlice.ts
export const characterSlice = createSlice({
  name: 'character',
  initialState,
  reducers: {
    selectCharacter: (state, action: PayloadAction<Character>) => {
      state.selectedCharacter = action.payload;
      // Сохраняем выбор персонажа в localStorage для сохранения между сессиями
      if (typeof window !== 'undefined') {
        localStorage.setItem('selectedCharacter', JSON.stringify(action.payload));
      }
    },
    // ... другие редьюсеры
  }
});
```

### Сохранение прогресса уровня
```typescript
// В компоненте уровня
useEffect(() => {
  if (currentStage) {
    localStorage.setItem('level1_progress', JSON.stringify({
      stage: currentStage,
      notes,
      completedStages,
      // Другие необходимые состояния
    }));
  }
}, [currentStage, notes, completedStages]);
```

### Восстановление прогресса
```typescript
// В компоненте уровня
useEffect(() => {
  // Попытка восстановить сессию из localStorage
  const savedLevel = localStorage.getItem('level1_progress');
  if (savedLevel) {
    try {
      const parsedLevel = JSON.parse(savedLevel);
      setCurrentStage(parsedLevel.stage);
      setNotes(parsedLevel.notes || []);
      setCompletedStages(parsedLevel.completedStages || []);
      // Другие необходимые состояния
    } catch (e) {
      console.error('Ошибка при загрузке прогресса:', e);
    }
  }
}, []);
```

## Безопасность

### Текущие ограничения
- Данные в localStorage доступны для чтения и изменения из JavaScript
- Нет защиты от манипуляций с прогрессом
- Нет возможности восстановления данных при удалении localStorage

### Планируемые улучшения
- Шифрование данных в localStorage для предотвращения манипуляций
- Проверка целостности данных при загрузке из localStorage
- Хранение критически важных данных на сервере
- Авторизация для всех API-запросов, связанных с прогрессом
- Логирование подозрительных изменений в прогрессе

## Пользовательский сценарий
1. Пользователь авторизуется в системе
2. Система обращается к API для получения последнего сохраненного состояния
3. Система автоматически загружает последнее сохраненное состояние:
   - Текущий персонаж
   - Доступные и пройденные уровни
   - Полученные предметы и награды
   - Статистика и достижения
4. В процессе игры система автоматически сохраняет прогресс через API при определенных событиях:
   - Завершение уровня
   - Получение награды
   - Изменение статуса персонажа
   - Периодические автосохранения
5. При выходе из игры все изменения сохраняются в базе данных
6. При повторном входе пользователь продолжает с последнего сохраненного состояния, синхронизируя данные между клиентом и сервером

## Типы сохраняемых данных

### 1. Данные профиля пользователя
- Базовая информация аккаунта
- Настройки пользователя
- История входов

### 2. Данные персонажа
- Имя и тип персонажа
- Характеристики и уровень
- Предметы и экипировка
- Навыки и способности

### 3. Данные прогресса по уровням
- Статус прохождения каждого уровня
- История принятых решений
- Полученные результаты и оценки
- Количество попыток и время прохождения

### 4. Данные наград и достижений
- Полученные предметы
- Разблокированные достижения
- Опыт и другие показатели прогресса
- Бонусы и модификаторы

## Технические требования

### Фронтенд
1. Механизм кэширования данных на клиенте
   - Локальное сохранение текущего состояния (IndexedDB или localStorage)
   - Отображение индикаторов сохранения
   - Обработка конфликтов между локальным и серверным сохранением
   - Стратегия оффлайн-работы с последующей синхронизацией

2. Компоненты:
   - Индикатор статуса синхронизации
   - Система уведомлений о сохранении/загрузке
   - Интерфейс управления сохранениями (если применимо)
   - Компонент для разрешения конфликтов синхронизации
   - Обработка и отображение ошибок синхронизации

### Бэкенд
1. API для получения текущего состояния
   - Метод: GET
   - Endpoint: `/api/users/:id/state`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Возвращает полную информацию о текущем состоянии пользователя
   - Поддержка частичного получения данных через параметры запроса

2. API для сохранения текущего состояния
   - Метод: PUT
   - Endpoint: `/api/users/:id/state`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Входные данные:
     - user_id (из токена авторизации)
     - state_data (новое состояние)
     - timestamp (время сохранения)
   - Валидация входных данных
   - Атомарное обновление состояния

3. API для синхронизации между устройствами
   - Метод: POST
   - Endpoint: `/api/users/:id/sync`
   - Требует авторизации (JWT токен)
   - Проверка прав доступа
   - Входные данные:
     - user_id (из токена авторизации)
     - device_id (идентификатор устройства)
     - local_state (локальное состояние)
     - last_sync (время последней синхронизации)
   - Распознавание и разрешение конфликтов
   - Журналирование синхронизаций для аудита

4. API для резервного копирования состояния
   - Метод: POST
   - Endpoint: `/api/users/:id/backup`
   - Требует авторизации (JWT токен)
   - Создает резервную копию текущего состояния
   - Возвращает идентификатор резервной копии

### База данных
1. Коллекция `user_state`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `character_state`: Object (состояние персонажа)
   - `level_progress`: Object (прогресс по уровням)
   - `inventory`: Array (инвентарь персонажа)
   - `achievements`: Array (достижения)
   - `settings`: Object (настройки пользователя)
   - `last_updated`: Date (время последнего обновления)
   - `version`: Number (версия состояния)
   - `is_deleted`: Boolean (флаг удаления)

2. Коллекция `sync_history`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `device_id`: String (идентификатор устройства)
   - `sync_timestamp`: Date (время синхронизации)
   - `sync_data`: Object (данные синхронизации)
   - `status`: String (статус синхронизации)
   - `conflict_resolution`: String (способ разрешения конфликта, если был)
   - `ip_address`: String (IP-адрес для аудита)

3. Коллекция `backups`:
   - `_id`: ObjectId
   - `user_id`: ObjectId (ссылка на пользователя)
   - `created_at`: Date (время создания копии)
   - `state_data`: Object (полная копия состояния)
   - `reason`: String (причина создания резервной копии)
   - `created_by`: String (кто создал: система или пользователь)

### Индексы базы данных
1. `user_state`:
   - `user_id`: 1 (для быстрого поиска)
   - `last_updated`: -1 (для сортировки по времени)

2. `sync_history`:
   - `user_id`: 1, `device_id`: 1 (для фильтрации по пользователю и устройству)
   - `sync_timestamp`: -1 (для сортировки по времени)

## Механизм синхронизации
1. Последовательность событий при входе пользователя:
   - Пользователь авторизуется через JWT
   - Клиент проверяет наличие локальных данных
   - Клиент запрашивает последнее состояние с сервера с временной меткой последней синхронизации
   - Проводится сравнение локальных и серверных данных на основе временных меток и версионирования
   - При конфликте: применяется стратегия разрешения конфликтов
   - Синхронизированные данные загружаются на клиент
   - Обновляется временная метка последней синхронизации

2. Периодическая синхронизация:
   - Автоматическое сохранение при достижении контрольных точек с отправкой на сервер
   - Фоновая синхронизация с заданным интервалом (каждые 5 минут)
   - Принудительное сохранение при выходе из приложения
   - Дифференциальные обновления для уменьшения объема передаваемых данных

3. Обработка конфликтов:
   - Стратегия разрешения конфликтов на основе временных меток и версионирования
   - Приоритет серверных данных при невозможности определить новизну
   - Логирование конфликтов для анализа и поддержки
   - Механизм ручного разрешения конфликтов для критических данных

### Обеспечение целостности данных
1. Транзакционные обновления состояния
2. Версионирование данных
3. Автоматические резервные копии перед значительными изменениями
4. Механизм восстановления из резервных копий
5. Валидация структуры данных на клиенте и сервере

## Безопасность
1. Аутентификация через JWT для всех API-запросов
2. Проверка прав доступа на сервере
3. Шифрование чувствительных данных
4. Ограничение частоты запросов (rate limiting)
5. Журналирование операций для аудита
6. Защита от CSRF и инъекций

## Интеграционные требования
1. Сохранение должно происходить без прерывания игрового процесса
2. Система должна корректно обрабатывать сценарии с отсутствием сетевого соединения
3. Необходима защита от потери данных при сбоях
4. Интеграция с системой аутентификации для обеспечения безопасности данных пользователя
5. Минимизация объема передаваемых данных для экономии трафика
6. Поддержка разных версий клиента через совместимость форматов данных

## Критерии готовности
1. Прогресс пользователя корректно сохраняется при всех ключевых игровых событиях
2. Данные успешно синхронизируются между разными устройствами при входе пользователя
3. Система корректно обрабатывает конфликты при синхронизации
4. Производительность сохранения не влияет на игровой процесс
5. Система обеспечивает безопасность данных пользователя
6. Пользователь может видеть индикацию статуса сохранения/загрузки
7. Система корректно работает при временном отсутствии соединения
8. Механизм резервного копирования и восстановления работает корректно
9. Данные сохраняются атомарно, без частичных обновлений
10. Система способна обрабатывать большое количество одновременных запросов 