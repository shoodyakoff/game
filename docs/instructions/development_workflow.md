# Процесс разработки PM-Game

## Общий подход
1. **Обсуждение ТЗ**: Перед разработкой каждой функции согласовываем требования
2. **Разработка**: Реализация кода в соответствии с ТЗ
3. **Ревью и правки**: Обсуждение реализации, внесение корректировок
4. **Обновление документации**: После финальных правок обновляем ТЗ и PRD

## Файлы документации
- `docs/prd/` - Директория с Product Requirements Document
   - `main.md` - Основной PRD документ
   - `features/` - Детальные требования по отдельным функциям
- `docs/instructions/` - Инструкции по разработке

## Принципы разработки
1. **Модульность**: Разделение кода на независимые компоненты
   - Создание переиспользуемых компонентов для типовых элементов (диалоги, выборы, саммари)
   - Отделение контента от представления через JSON/YAML конфигурации
   - Уровни должны легко создаваться на основе существующих шаблонов без дублирования кода

2. **Масштабируемость**: Проектирование с учетом будущего роста
   - Архитектура должна позволять легко добавлять новые типы уровней и контента
   - Поддержка растущего количества пользователей и уровней
   - Подготовка к интеграции с внешними API (OpenAI)

3. **Безопасность**: Особое внимание к авторизации и хранению данных
   - Защита пользовательских данных
   - Безопасное хранение ключей API (OpenAI)
   - Проверка и фильтрация пользовательского ввода

4. **Документирование**: Поддержание актуальной документации
   - Подробное описание API и компонентов
   - Документирование шаблонов для новых уровней
   - Документирование процесса добавления нового контента

## Работа с персонажами и изображениями
1. **Структура изображений**:
   - Все изображения персонажей хранятся в директории `public/images/characters/`
   - Иконки персонажей: `public/images/characters/icons/{character_type}.png`
   - Полные изображения: `public/images/characters/full/{character_type}.png`
   - Все имена файлов должны быть в нижнем регистре, без пробелов

2. **Хранение информации о персонажах**:
   - Все типы персонажей определены в файле `src/constants/characters.ts`
   - Каждый персонаж включает пути к изображениям и все необходимые атрибуты
   - Модель `Character` в базе данных должна хранить тип персонажа, не пути

3. **Отображение персонажей**:
   - Использовать компонент `CharacterImage` для отображения персонажей
   - Передавать тип персонажа, не путь к изображению
   - Компонент самостоятельно определяет правильный путь к изображению

## Работа со стилями
1. **Сохранение существующих стилей**:
   - При обновлении логики компонентов не менять существующие стили
   - Если стиль уже определен, использовать его без изменений
   - Избегать дублирования стилей

2. **Модульность стилей**:
   - Использовать CSS модули для изоляции стилей компонентов
   - Глобальные стили только для общих элементов

3. **Работа с Tailwind**:
   - Использовать утилитарные классы Tailwind для типовых стилей
   - Не создавать кастомные классы там, где достаточно Tailwind
   - Следовать существующим стилевым решениям в проекте

## Разработка страниц и маршрутизация
1. **Структура URL**:
   - Каждая функциональная часть должна иметь свой URL
   - Использовать структуру Next.js Pages Router
   - Поддерживать history API для корректной работы кнопок браузера

2. **Именование страниц**:
   - Страницы в директории `pages/` должны соответствовать URL структуре
   - Динамические страницы должны использовать синтаксис `[param].tsx`
   - Вложенные страницы должны использовать вложенные директории

3. **Защита маршрутов**:
   - Защищенные страницы должны проверять авторизацию
   - Перенаправлять неавторизованных пользователей на страницу логина
   - Сохранять intended URL для возврата после авторизации

## Интеграция с OpenAI API
1. **Подготовка инфраструктуры**:
   - Создание безопасного хранилища для ключей API
   - Разработка абстракции для работы с API
   - Подготовка шаблонов промптов для различных ситуаций

2. **Разработка интерфейса**:
   - Компоненты для взаимодействия с AI
   - Отображение прогресса и результатов
   - Корректная обработка ошибок и ограничений

3. **Безопасность и лимиты**:
   - Система квот и лимитов для пользователей
   - Защита от злоупотребления API
   - Логирование всех взаимодействий с API

## Добавление новых уровней
1. **Использование существующих шаблонов**:
   - Создать JSON/YAML конфигурацию для нового уровня
   - Определить структуру диалогов, выборов и результатов
   - Поместить конфигурацию в соответствующую директорию

2. **Добавление новых компонентов** (если необходимо):
   - Создать новый компонент в соответствующей директории
   - Следовать принципам модульности
   - Интегрировать с существующей системой шаблонов

3. **Тестирование и валидация**:
   - Проверить правильность отображения нового уровня
   - Убедиться, что все взаимодействия работают корректно
   - Проверить корректность сохранения прогресса

## Формат взаимодействия
1. Разработка начинается после согласования ТЗ
2. Любые изменения в требованиях согласовываются отдельно
3. Обновление документации происходит по команде "Обнови документацию"
4. При необходимости дополнительных уточнений используется фраза "Уточни требования"
5. **Перед внесением изменений в код**: сначала предоставить детальное описание планируемых изменений без фактического редактирования файлов
   - Описать проблему и её причины
   - Предложить архитектурное решение
   - Объяснить логику будущих изменений в каждом файле
   - Только после согласования плана вносить изменения в код
6. При выполнении любых действий (изменение файлов, запуск команд) необходимо объяснять на доступном языке:
   - Что именно делается и зачем это нужно
   - Какой результат ожидается от выполнения действия
   - Как это действие связано с общей задачей

## Тестирование и проверка
1. **Функциональное тестирование**:
   - Проверка каждого сценария использования
   - Тестирование на разных устройствах
   - Проверка всех возможных исходов уровней

2. **UI/UX тестирование**:
   - Проверка корректности отображения интерфейса
   - Проверка доступности и юзабилити
   - Соответствие дизайн-системе

3. **Производительность**:
   - Оптимизация загрузки ресурсов
   - Минимизация перерисовок компонентов
   - Эффективное использование кэширования 